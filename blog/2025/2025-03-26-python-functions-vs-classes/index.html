<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="draft-python-functions-vs-classes-for-building-powerful-python-cli-tools-with-bioinformatics-examples"><strong>[DRAFT] Python functions vs. classes for building powerful Python CLI tools with Bioinformatics examples</strong></h2> <p>Python has been my go-to language since I started working as a bioinformatician. However, I‚Äôve realised that I haven‚Äôt used classes as much as I should have.</p> <p>In the fast-moving field of bioinformatics, Python is a top choice for building command-line interface (CLI) tools‚Äîthanks to its simplicity, rich ecosystem, and flexibility. Whether you‚Äôre writing a quick script to process genomic data or developing a complex pipeline for sequence analysis, choosing between functions and classes can significantly impact your code‚Äôs efficiency, maintainability, and scalability.</p> <p>In this blog, we‚Äôll break down the key differences between functions and classes, explore when to use each, and provide real-world bioinformatics examples. Along the way, I‚Äôll share insights into how getting comfortable with Python classes can enhance your ability to build robust CLI tools.</p> <h3 id="functions-vs-classes-a-visual-overview"><strong>Functions vs. classes: a visual overview</strong></h3> <p>To illustrate the fundamental difference between functions and classes, here‚Äôs a simple diagram:</p> <pre><code class="language-mermaid">graph TD
  subgraph Functions
    A[Input] --&gt;|Processed by function| B[Output]
  end

  subgraph Classes
    C[Input] --&gt;|Processed by constructor| D[Instance with State]
    D --&gt;|Method Call| E[Output]
  end
</code></pre> <ul> <li> <strong>Functions</strong> take an input, process it, and return an output.</li> <li> <strong>Classes</strong> not only take input and produce output but also maintain a state, allowing data to persist across method calls.</li> </ul> <hr> <h3 id="python-functions-making-your-code-reusable"><strong>Python functions: making your code reusable</strong></h3> <p>One of the core principles of programming is <strong>DRY</strong>‚Äî<em>‚ÄúDon‚Äôt Repeat Yourself.‚Äù</em> I‚Äôve relied on functions to make my code more reusable and efficient from the start. Functions are <strong>straightforward and simple</strong>. They act as self-contained blocks of code designed to perform a specific task. Functions are particularly useful when you need to repeat an operation multiple times but don‚Äôt want to rewrite the same code. They are perfect for operations that don‚Äôt require maintaining state between calls.</p> <h4 id="hmm-what-does-maintaining-state-between-calls-mean"><strong>Hmm‚Ä¶ What Does ‚ÄúMaintaining State Between Calls‚Äù Mean?ü§î</strong></h4> <p>When we say functions don‚Äôt ‚Äúmaintain state between calls,‚Äù it simply means that every time you call a function, it starts fresh‚Äîforgetting anything from previous runs. Functions take input, process it, and return an output without remembering any past data.</p> <p>For example, if you construct a function to calculate the <strong>GC content</strong> (the percentage of guanine and cytosine) in a DNA sequence‚Äîa common task in bioinformatics‚Äîyou can use a simple function like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gc_content</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Calculate the GC content percentage of a DNA sequence.</span><span class="sh">"""</span>
    <span class="n">gc_count</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">G</span><span class="sh">"</span><span class="p">)</span> <span class="o">+</span> <span class="n">sequence</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">gc_count</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

<span class="c1"># Usage
</span><span class="n">dna_seq</span> <span class="o">=</span> <span class="sh">"</span><span class="s">ATGCGATACGCTTGC</span><span class="sh">"</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">GC Content:</span><span class="sh">"</span><span class="p">,</span> <span class="nf">gc_content</span><span class="p">(</span><span class="n">dna_seq</span><span class="p">))</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">gc_content</code> is the <strong>function name</strong>, and <code class="language-plaintext highlighter-rouge">sequence</code> is a <strong>parameter</strong> that allows you to pass any DNA sequence as input. The function counts the number of <strong>G</strong> and <strong>C</strong> nucleotides in the sequence and returns the GC content percentage. <code class="language-plaintext highlighter-rouge">sequence.count("G") + sequence.count("C")</code> counts the <strong>G</strong> and <strong>C</strong> nucleotides, while <code class="language-plaintext highlighter-rouge">return 100 * gc_count / len(sequence)</code> computes and returns the GC content percentage.</p> <p>Functions like this are great when you have <strong>clear inputs and outputs</strong> without needing to store extra data. But what if your program requires keeping track of information across multiple calls? That‚Äôs where <strong>classes</strong> come in‚Äîlet‚Äôs explore that next!</p> <hr> <h3 id="python-classes-organising-data-and-behavior"><strong>Python classes: organising data and behavior</strong></h3> <p>While functions are great for simple, reusable operations, <strong>classes</strong> take things a step further. Classes act as blueprints for creating objects that bundle both <strong>data</strong> and <strong>behavior</strong> (methods). They are incredibly useful when you want to maintain <strong>state</strong> between calls or model complex entities. In bioinformatics, this is particularly relevant when you need to represent biological sequences, genes, or proteins.</p> <p>Imagine you‚Äôre developing a <strong>bioinformatics CLI tool</strong> that processes various biological sequence records. Instead of passing raw data between functions, you can create a <code class="language-plaintext highlighter-rouge">SequenceRecord</code> class to encapsulate relevant properties (like the sequence ID and nucleotide string) alongside methods for operations such as <strong>transcription</strong> or <strong>reverse complement calculation</strong>. Note it is a norm to name the class in a Pascal case, i.e. each word starts with a uppercase letter without spaces (e.g. <code class="language-plaintext highlighter-rouge">SequenceRecord</code> instead of <code class="language-plaintext highlighter-rouge">sequence_record</code>).</p> <h4 id="example-using-a-class-for-sequence-records"><strong>Example: using a class for sequence records</strong></h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SequenceRecord</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span>

    <span class="k">def</span> <span class="nf">gc_content</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">gc_count</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">G</span><span class="sh">"</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">gc_count</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse_complement</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">complement</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">T</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">T</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">G</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">G</span><span class="sh">"</span><span class="p">}</span>
        <span class="k">return</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">complement</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Usage of SequenceRecord class
</span><span class="n">record</span> <span class="o">=</span> <span class="nc">SequenceRecord</span><span class="p">(</span><span class="sh">"</span><span class="s">seq1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ATGCGATACGCTTGC</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Accessing object properties and methods
</span><span class="nf">print</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Sequence:</span><span class="sh">"</span><span class="p">,</span> <span class="n">record</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Identifier:</span><span class="sh">"</span><span class="p">,</span> <span class="n">record</span><span class="p">.</span><span class="n">identifier</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">GC Content:</span><span class="sh">"</span><span class="p">,</span> <span class="n">record</span><span class="p">.</span><span class="nf">gc_content</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Reverse Complement:</span><span class="sh">"</span><span class="p">,</span> <span class="n">record</span><span class="p">.</span><span class="nf">reverse_complement</span><span class="p">())</span>
</code></pre></div></div> <h4 id="output"><strong>Output:</strong></h4> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&lt;__main__.SequenceRecord object at 0x0000023EE513CF10&gt;</span><span class="w">
</span><span class="go">Sequence: ATGCGATACGCTTGC
Identifier: seq1
GC Content: 53.33%
Reverse Complement: GCAAGCGTATCGCAT
</span></code></pre></div></div> <p>Note, when you print the <code class="language-plaintext highlighter-rouge">record</code> object by itself, it shows the memory address of the object. The class <code class="language-plaintext highlighter-rouge">SequenceRecord</code> bundles related data and methods together, making it easier to manage and manipulate sequence records. In this example, there are two methods: <code class="language-plaintext highlighter-rouge">gc_content</code> and <code class="language-plaintext highlighter-rouge">reverse_complement</code>, which operate on the sequence data stored in the object. <code class="language-plaintext highlighter-rouge">record</code> is an <strong>instance</strong> of the <code class="language-plaintext highlighter-rouge">SequenceRecord</code> class, and you can call its methods to perform operations on the sequence data. _If you want an analogy, think of a class as a form that needs to be filled out. The instance of the class is the filled-out form, which contains the data you entered._Each instance (like <code class="language-plaintext highlighter-rouge">record</code>) contains unique data but follows the same structure. By using a class, you can group related methods and state together, making it easier to manage complex workflows‚Äîespecially when your CLI tool must handle multiple types of data.</p> <hr> <h3 id="when-to-use-functions-vs-classes"><strong>When to use functions vs. classes</strong></h3> <h4 id="simplicity-vs-structure"><strong>Simplicity vs. Structure</strong></h4> <table> <thead> <tr> <th>Use Functions When‚Ä¶</th> <th>Use Classes When‚Ä¶</th> </tr> </thead> <tbody> <tr> <td>Your task is <strong>simple and stateless</strong> </td> <td>You need to <strong>group related data and behavior</strong> </td> </tr> <tr> <td>You just need a <strong>single reusable operation</strong> </td> <td>Your code requires <strong>maintaining state</strong> between calls</td> </tr> <tr> <td>You want a <strong>quick, lightweight approach</strong> </td> <td>You‚Äôre working with <strong>complex data structures</strong> </td> </tr> <tr> <td>Example: Computing <strong>GC content</strong> </td> <td>Example: Representing <strong>biological sequences</strong> </td> </tr> </tbody> </table> <p>In bioinformatics, functions work best for <strong>small, focused tasks</strong>, while classes shine when dealing with <strong>structured data</strong> like <strong>genes, proteins, or sequence records</strong>.</p> <hr> <h3 id="building-cli-tools-combining-functions-and-classes"><strong>Building CLI tools: combining functions and classes</strong></h3> <p>Modern <strong>Python CLI tools</strong> often mix both approaches. Libraries like <strong>argparse</strong> or <strong>Click</strong> help process command-line arguments while keeping the core logic clean and modular. Let‚Äôs look at an example:</p> <h4 id="example-fasta-file-parser-with-a-cli"><strong>Example: FASTA file parser with a CLI</strong></h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">argparse</span>

<span class="k">class</span> <span class="nc">FastaRecord</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span>

    <span class="k">def</span> <span class="nf">gc_content</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">gc_count</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">G</span><span class="sh">"</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">gc_count</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">parse_fasta</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">seq_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">&gt;</span><span class="sh">"</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">identifier</span><span class="p">:</span>
                    <span class="n">records</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">FastaRecord</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">seq_lines</span><span class="p">)))</span>
                <span class="n">identifier</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Remove '&gt;'
</span>                <span class="n">seq_lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seq_lines</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">identifier</span><span class="p">:</span>
            <span class="n">records</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">FastaRecord</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">seq_lines</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">records</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">Process FASTA files and compute GC content.</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">"</span><span class="s">fasta_file</span><span class="sh">"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">Path to the FASTA file</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>

    <span class="n">records</span> <span class="o">=</span> <span class="nf">parse_fasta</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">fasta_file</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">record</span><span class="p">.</span><span class="n">identifier</span><span class="si">}</span><span class="s">: GC Content = </span><span class="si">{</span><span class="n">record</span><span class="p">.</span><span class="nf">gc_content</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">%</span><span class="sh">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">main</span><span class="p">()</span>
</code></pre></div></div> <h4 id="how-this-code-works"><strong>How this code works</strong></h4> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">FastaRecord</code> Class:</strong> Stores the sequence <strong>ID</strong> and <strong>nucleotide string</strong>, providing a method to compute <strong>GC content</strong>.</li> <li> <strong><code class="language-plaintext highlighter-rouge">parse_fasta</code> Function:</strong> Reads a <strong>FASTA file</strong>, extracts sequence data, and creates <code class="language-plaintext highlighter-rouge">FastaRecord</code> objects.</li> <li> <strong><code class="language-plaintext highlighter-rouge">main</code> Function:</strong> Uses <strong>argparse</strong> to accept a <strong>file path</strong> as input, then processes and prints GC content for each sequence in the file.</li> </ol> <h4 id="running-the-cli-tool-on-real-data"><strong>Running the CLI Tool on real data</strong></h4> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># copy the python code above into a file called fasta_gc.py</span>
nano fasta_gc.py
<span class="c"># download a sequence file of a sample bacterial genome of Haemophilus influenzae</span>
wget https://raw.githubusercontent.com/MDU-PHL/hicap/refs/heads/master/example/Hi75.fasta
<span class="c"># view the FASTA file</span>
less Hi75.fasta
<span class="c"># run the CLI tool to compute GC content and print the first few lines of output</span>
python fasta_gc.py Hi75.fasta | <span class="nb">head</span>
</code></pre></div></div> <h4 id="sample-output"><strong>Sample output:</strong></h4> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">NODE_1: GC Content = 37.41%
NODE_2: GC Content = 37.34%
NODE_3: GC Content = 37.73%
NODE_4: GC Content = 38.46%
NODE_5: GC Content = 37.63%
</span></code></pre></div></div> <p>Viola! You‚Äôve built a simple CLI tool to parse FASTA files and compute GC content and tested it on a real dataset.</p> <p>With this approach, we <strong>separate concerns</strong>:</p> <ul> <li> <strong>File parsing</strong> is handled by a <strong>function</strong> (<code class="language-plaintext highlighter-rouge">parse_fasta</code>).</li> <li> <strong>Sequence representation and operations</strong> are handled by a <strong>class</strong> (<code class="language-plaintext highlighter-rouge">FastaRecord</code>).</li> <li> <strong>Command-line interaction</strong> is handled by <strong>argparse</strong> in the <code class="language-plaintext highlighter-rouge">main()</code> function.</li> </ul> <p>This <strong>modular design</strong> makes it easier to test, maintain, and extend.</p> <hr> <p>If you are interested in diving deeper, there‚Äôs a whole philosophy of <strong>Object-Oriented Programming (OOP)</strong> built around classes. Python is a <strong>dynamic</strong> language that supports both <strong>functional</strong> and <strong>object-oriented</strong> programming.</p> <ul> <li> <strong>Some languages, like Java, are class-heavy</strong>, forcing everything into objects.</li> <li> <strong>Others, like Haskell, follow a functional paradigm</strong>, relying entirely on pure functions.</li> <li> <strong>Python gives you the best of both worlds</strong>, allowing you to choose the right tool for the job.</li> </ul> <h3 id="finding-the-right-balance"><strong>Finding the Right Balance</strong></h3> <p>If you‚Äôve been writing <strong>large, monolithic functions</strong>, consider <strong>refactoring your code into classes</strong> for better structure. However, <strong>not everything needs to be a class</strong>‚Äîsometimes, a well-designed function is the simplest and most effective approach.</p> <hr> <h3 id="final-thoughts"><strong>Final Thoughts</strong></h3> <p>Understanding the differences between <strong>functions and classes</strong> in Python is essential for writing <strong>clean, efficient, and scalable bioinformatics tools</strong>. By thoughtfully combining both, you can build <strong>powerful CLI tools</strong> that streamline your workflow and handle <strong>complex biological data</strong> with ease.</p> <p>For further exploration, check out these resources:</p> <ul> <li><a href="https://realpython.com/python3-object-oriented-programming/" rel="external nofollow noopener" target="_blank">Object-Oriented Programming (OOP) in Python</a></li> <li> </li> <li><a href="#">Python Functions ‚Äì A Primer for Computational Biology</a></li> <li><a href="https://biopython.org/docs/latest/Tutorial/chapter_introduction.html" rel="external nofollow noopener" target="_blank">Biopython Tutorial and Cookbook</a></li> <li><a href="https://simonwillison.net/2023/Sep/30/cli-tools-python/" rel="external nofollow noopener" target="_blank">Things I‚Äôve Learned About Building CLI Tools in Python ‚Äì Simon Willison</a></li> </ul> <p>Keep experimenting, keep coding, and most importantly‚Äîhave fun!</p> <p>Happy coding! üòä</p> </body></html>